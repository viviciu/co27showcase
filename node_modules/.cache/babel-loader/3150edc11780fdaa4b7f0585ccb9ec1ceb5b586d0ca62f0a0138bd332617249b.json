{"ast":null,"code":"import { AdditiveBlending, Color, HalfFloatType, MeshBasicMaterial, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n  constructor(resolution, strength, radius, threshold) {\n    super();\n    this.strength = strength !== undefined ? strength : 1;\n    this.radius = radius;\n    this.threshold = threshold;\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n\n    // create color only once here, reuse it later inside the render function\n    this.clearColor = new Color(0, 0, 0);\n\n    // render targets\n    this.renderTargetsHorizontal = [];\n    this.renderTargetsVertical = [];\n    this.nMips = 5;\n    let resx = Math.round(this.resolution.x / 2);\n    let resy = Math.round(this.resolution.y / 2);\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n    this.renderTargetBright.texture.generateMipmaps = false;\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizontal = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n      renderTargetHorizontal.texture.generateMipmaps = false;\n      this.renderTargetsHorizontal.push(renderTargetHorizontal);\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n      this.renderTargetsVertical.push(renderTargetVertical);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // luminosity high pass material\n\n    const highPassShader = LuminosityHighPassShader;\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    this.highPassUniforms['luminosityThreshold'].value = threshold;\n    this.highPassUniforms['smoothWidth'].value = 0.01;\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader\n    });\n\n    // gaussian blur materials\n\n    this.separableBlurMaterials = [];\n    const kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(this.resolution.x / 2);\n    resy = Math.round(this.resolution.y / 2);\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n      this.separableBlurMaterials[i].uniforms['invSize'].value = new Vector2(1 / resx, 1 / resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // composite material\n\n    this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n    this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n    this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n    this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n    this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n    this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n    this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n    const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n    this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n    this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n\n    // blend material\n\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.blendMaterial = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.basic = new MeshBasicMaterial();\n    this.fsQuad = new FullScreenQuad(null);\n  }\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n    this.renderTargetBright.dispose();\n\n    //\n\n    for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n      this.separableBlurMaterials[i].dispose();\n    }\n    this.compositeMaterial.dispose();\n    this.blendMaterial.dispose();\n    this.basic.dispose();\n\n    //\n\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    let resx = Math.round(width / 2);\n    let resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['invSize'].value = new Vector2(1 / resx, 1 / resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false);\n\n    // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    // 1. Extract Bright Areas\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n\n    // 2. Blur All the mips progressively\n\n    let inputRenderTarget = this.renderTargetBright;\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    }\n\n    // Composite All the mips\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n\n    // Blend it additively over the input texture\n\n    this.fsQuad.material = this.blendMaterial;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    }\n\n    // Restore renderer settings\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  }\n  getSeperableBlurMaterial(kernelRadius) {\n    const coefficients = [];\n    for (let i = 0; i < kernelRadius; i++) {\n      coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);\n    }\n    return new ShaderMaterial({\n      defines: {\n        'KERNEL_RADIUS': kernelRadius\n      },\n      uniforms: {\n        'colorTexture': {\n          value: null\n        },\n        'invSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        // inverse texture size\n        'direction': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'gaussianCoefficients': {\n          value: coefficients\n        } // precomputed Gaussian coefficients\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n    });\n  }\n  getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        'NUM_MIPS': nMips\n      },\n      uniforms: {\n        'blurTexture1': {\n          value: null\n        },\n        'blurTexture2': {\n          value: null\n        },\n        'blurTexture3': {\n          value: null\n        },\n        'blurTexture4': {\n          value: null\n        },\n        'blurTexture5': {\n          value: null\n        },\n        'bloomStrength': {\n          value: 1.0\n        },\n        'bloomFactors': {\n          value: null\n        },\n        'bloomTintColors': {\n          value: null\n        },\n        'bloomRadius': {\n          value: 0.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n    });\n  }\n}\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"names":["AdditiveBlending","Color","HalfFloatType","MeshBasicMaterial","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","LuminosityHighPassShader","UnrealBloomPass","constructor","resolution","strength","radius","threshold","undefined","x","y","clearColor","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","type","texture","name","generateMipmaps","i","renderTargetHorizontal","push","renderTargetVertical","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","bloomFactors","bloomTintColors","copyShader","copyUniforms","blendMaterial","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","coefficients","exp","defines"],"sources":["/Users/vivianastaicu/Documents/GitHub/co27showcase/co27showcase/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tMeshBasicMaterial,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizontal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader\n\t\t} );\n\n\t\t// gaussian blur materials\n\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// blend material\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.blendMaterial = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\n\n\t\t}\n\n\t\tthis.compositeMaterial.dispose();\n\t\tthis.blendMaterial.dispose();\n\t\tthis.basic.dispose();\n\n\t\t//\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.blendMaterial;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );\n\n\t\t}\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}